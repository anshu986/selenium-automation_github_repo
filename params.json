{
  "name": "Selenium-automation",
  "tagline": "Selenium automation framework is not only a test automation framework, but also the best practice of using Selenium. It integrates a lot of 'new way' to the framework and provide you a new natural way to design and describe your pages. No more FlowWait for WebElement, new more new Page(), new more new Select(), no more WebElement.isDisplayed() in your test case. It provides more than that, please see the details.  ",
  "body": "Welcome to Selenium Automation Framework!\r\n===================\r\n**Selenium automation framework** is not only a java automation framework, but also the best practice of using Selenium.\r\nI used selenium for years. A lot of reason to love him, but a lot of reason to hate him. This integrates a lots of selenium good practice to framework and provide you with reusable component. I listed a lot of **A new way** here. If you are impressed by any of them, please just down it and try it. Buy me a beer if you love it.\r\n\r\nThis framework provides:\r\n - A new way to describe and organize you pages.\r\n - A new way you don't need to validate elements' presence when creating a page.\r\n - A new way to run test against different browser like IE, Chrome, Firefox and even Selenium Grid\r\n - A new way to use Select, Checkbox and RadioButton.\r\n - A new way to handle navigation.\r\n  ...\r\n\r\nA new way to describe and organize your pages.\r\n-------------\r\nDo you follow PageObjects pattern? if yes, you already have a good start. Can you help to describe home www.expedia.com? If we describe it in nature language, it should like this:\r\n\r\n    A HomePage includes a header, a navigation page, a search component, Deals, and footer.\r\n    - header provides account management, language ...\r\n    - navigation page includes flight, hotel, car ...\r\n    - search includes pickup location, dropoff location ...\r\n    - deals includes ...\r\n\r\nIn the old way, because java doesn't support multiple inheritance, we may describe it like this:\r\n\r\n    class HeaderPage {\r\n\t    @Findby(id=\"account\")\r\n\t    WebElement accountManagement;\r\n\t}\r\n\t\r\n\tclass NavigationPage extends HeaderPage {\r\n\t\t@FindBy(id=\"flight\")\r\n\t\tWebElement flight;\r\n\t}\r\n\tclass HomePage extends NavigationPage {\r\n\t}\r\n\r\nAs a workaround, we may describe it like this:\r\n\r\n    class HeaderPage{}\r\n    class NavigationPage{}\r\n    class HomePage{}\r\nBut in order to verify if all WebElement is present in homepage, we need to verify all Page separately:\r\n\r\n    HeaderPage header = new HeadPage();\r\n    NavigationPage nav = new NavigationPage();\r\n    HomePage homePage = new HomePage();\r\n    verify(header);\r\n    verify(nav);\r\n    verify(homePage);\r\n\r\nAnd from HomePage itself, it's hard to know which Pages are subPages in HomePage.\r\n\r\nThis framework provides a nature way to organize and describe your Pages.\r\n\r\n**New Code Sample**\r\n\r\n    class Header extends Container{\r\n\t    @Findby(id=\"account\")\r\n\t    WebElement accountManagement;\r\n\t}\r\n\r\n\tclass Navigation extends Container{\r\n\t\t@FindBy(id=\"flight\")\r\n\t\tWebElement flight;\r\n\t}\r\n\tclass HomePage extends Page{\r\n\t\t@FindBy(id=\"head\")\r\n\t\tHeader head;\r\n\t\t\r\n\t\t@FindBy(id=\"nav\")\r\n\t\tNavigation nav;\r\n\t}\r\nDo you see the difference? Bingo, Framework introduced Container class, and now you can use **Header** and **Navigation** just the same way as **WebElement**. Navigation and Header will be a reusable component and be used by more pages. If you need it, just define it in your page and add FindBy just like a WebElement, framework will help you do the left.\r\n\r\nA new way you don't need to validate elements' presence when creating a page.\r\n-------------\r\nIf your HomePage only have one mandatory nav WebElement, Have you written this code:\r\n\r\n\tpublic class HomePage{\r\n\t\t@FindBy(id=\"wizard-theme-wrapper\")\r\n\t\tWebElement nav;\r\n\r\n\t\t@FindBy(id=\"footer\")\r\n\t\tWebElement footer;\r\n\r\n\t   public boolean isDisplayed() {\r\n\t\t    try {\r\n\t\t\t    return nav.isDisplayed();\r\n\t\t\t} catch (final NoSuchElementException e) {\r\n\t\t\t\treturn false;\r\n\t\t\t} catch (final StaleElementReferenceException e)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic doSearch() {\r\n\t\t\tnav.toCarSearchPage();\r\n\t\t}\r\n\t}\t\r\n   \r\n    public class HomePageTest {\r\n       @Test\r\n       public void homePageTest () {\r\n    \t\tHomePage page = PageFactory.initElements(driver, HomePage.class);\r\n    \t\tWait<WebDriver> wait = new WebDriverWait(webDriver, 100);\r\n    \t\twait.until(new ExpectedCondition<Boolean>() {\r\n    \t\t\tpublic Boolean apply(final WebDriver webDriver) {\r\n    \t\t\t\treturn homePage.isDisplayed();\r\n    \t\t\t}\r\n    \t\t});\r\n\r\n    \t\tpage.doSearch();\r\n    \t}\r\n    }   \r\n\r\nYou are not the only one. I wrote tons of this kind of test cases before. Now you don't need to do it any more.\r\n\r\n**New Code Sample**\r\n\r\n    @AutoValidation\r\n    public class HomePage extends Page {\r\n        @FindBy(id=\"wizard-theme-wrapper\")\r\n        Navigation nav;\r\n\r\n        @OptionalElement\r\n\t\t@FindBy(id=\"footer\")\r\n\t\tWebElement footer;\r\n        public void doSearch() {\r\n            nav.toCarSearchPage();\r\n        }\r\n    }\r\n\r\n    public class HomePageTest {\r\n       @Test\r\n       public void homePageTest () {\r\n           HomePage page = new HomePage();\r\n           page.doSearch();\r\n       }\r\n    }\r\n\r\nVery simple, right? Just add @AutoValidation to your test Page class, and add @OptionalElement to skip the Element you don't want to auto validate its presence. Even more, you can remove @AutoValidation, by default, the framework helps you verify that all elements should exists when you **new HomePage()**.\r\n\r\nA new way to run test against different browser like IE, Chrome, Firefox and even Selenium Grid\r\n-------------\r\nDo you want to make your test case run against IE, Chrome, Firefox and Selenium Grid without any modification? Don’t assume that driver will be an instance of FireFoxDriver or InternetExplorerDriver only. maybe It’s quite easy for you to create a small framework around selenium. Now it's ready for you to use.\r\nJust change the configuration in **config/automation.properties** to the browser you need. we support Firefox, Chrome, IE to run locally and any browser Remotely.\r\n\r\n    browserName=chrome\r\n    waitDurationInSeconds=60\r\n    remoteWebDriverAddress=\r\n\r\nIf you use mvn to do the test, you can even changed the behaviour dynamically by **mvn test -DbrowserName=firefox**.\r\nIf you need run against RemoteWebDriver like Selenium Grid, all you  need to do is define a remoteWebDriverAddress. framework would do the left work for you. eg:\r\n\r\n    browserName=chrome\r\n    waitDurationInSeconds=60\r\n    remoteWebDriverAddress=http://localhost:4444/wd/hub\r\n\r\nIf you want to talk to Remote WebDriver and want different DesiredCapabilities, just defined a config file in config/${browserName}.properties. Framework would load this file automatically and negotiate with remote webdriver. Here is an example for firefox\r\n\r\n    config/browser/firefox.properties\r\n        browserName=firefox\r\n        version=\r\n        platform=WINDOWS\r\n        javascriptEnabled=true\r\n        cssSelectorsEnabled=true\r\n\r\nA new way to handle Ajax pages\r\n-------------\r\nHow many times we use FluentWait to wait for a ajax page in our test cases. Do you ever use org.openqa.selenium.support.pagefactory.AjaxElementLocatorFactory. now framework makes it very simple and you need to do nothing. By default, all WebElement are initialized with AjaxElementLocatorFactory. If you are using ajaxElement like ajaxElement.click() and the element doesn't exist, it would wait for this element until it timeouts.\r\n\r\n    public class HomePage {\r\n        @FindBy(id=\"ajax\")\r\n        @OptionalElement\r\n        WebElement ajaxElement;\r\n\r\n        public void doSomething() {\r\n            ajaxElement.click();\r\n        }\r\n    }\r\n\r\nIf you want to use implicit wait and fail immediately if no element is present, you just add @AjaxEnabled(false) to your class.\r\n\r\n    @AjaxEnabled(false)\r\n    public class HomePage {\r\n        @FindBy(id=\"ajax\")\r\n        @OptionalElement\r\n        WebElement ajaxElement;\r\n\r\n        public void doSomething() {\r\n            ajaxElement.click();\r\n        }\r\n    }\r\n\r\n\r\nA new way you don't need to call findElement(s) any more\r\n-------------\r\nI think we have two scenarios we need call findElement by yourself. One is for things like Select and RadioButton. You may have this code:\r\n\r\n    Select foo = new Select(sDriver.findElement(By.id(\"foo\")));\r\n    foo.selectByValue(\"myValue\");\r\n\r\nPlease use SelectBox and make it OptionalElement if it's dynamically created.\r\n\r\n    public class HomePage {\r\n        @FindBy(id=\"ajax\")\r\n        @OptionalElement\r\n        SelectBox select;\r\n\r\n        public void doSomething() {\r\n           select.selectByIndex(10);\r\n        }\r\n    }\r\n\r\n\r\nAnother one is find element relative to other element. Please use Container(see details in 'A new way to describe tables.')\r\n\r\nA new way to use Select, Checkbox and RadioButton.\r\n-------------\r\nHave you written this test case?\r\n\r\n    public class DemoPage{\r\n        @FindBy(id=\"selectdemo\")\r\n        WebElement selectElement;\r\n\r\n        @FindBy(id=\"checkboxDemo\")\r\n        WebElement checkBoxElement;\r\n\r\n        public void selectByValue(String value) {\r\n            new Select(selectElement).selectByValue(value);\r\n        }\r\n\r\n        public void check() {\r\n            if (!checkBoxElement.isSelected()) {\r\n                checkBoxElement.click();\r\n            }\r\n        }\r\n    }\r\n\r\nToday you can treat Select and CheckBox just as WebElement, and you don't need to create a new Select() any more.\r\n\r\n**New Code Sample**\r\n\r\n    public class DemoPage{\r\n        @FindBy(id=\"selectdemo\")\r\n        SelectBox selectElement;\r\n\r\n        @FindBy(id=\"checkboxDemo\")\r\n        CheckBox checkBoxElement;\r\n\r\n        public void selectByValue(String value) {\r\n            selectElement.selectByValue(value);\r\n        }\r\n\r\n        public void check() {\r\n            checkBoxElement.check();\r\n        }\r\n    }\r\n\r\nA new way to use @Rule annotation.\r\n-------------\r\nIf you never use @Rule, I suggest you google it. It's worth your time to learn it and use it in your test framework.\r\nIn the old ways, I always write this kind of test case\r\n\r\n    class DemoTest {\r\n        private WebDriver driver;\r\n\r\n        @Setup\r\n        public void setup() {\r\n            ProfilesIni allProfiles = new ProfilesIni();\r\n            FirefoxProfile profile = allProfiles.getProfile(\"selenium\");\r\n            WebDriver driver = FirefoxDriver(profile);\r\n        }\r\n\r\n        @Test\r\n        public void demoTest() {\r\n            driver.navigate().to(\"https://www.amazon.com\")\r\n            HomePage homePage = new HomePage();\r\n            // homePage.initElements(driver);\r\n            // homePage.waitForSomething();\r\n            homePage.toCarSearchPage();\r\n        }\r\n    }\r\n\r\n**New Code Sample**\r\n\r\n\r\n\tclass DemoTest {\r\n\t\t@Rule\r\n\t\tpublic AutomationDriver automationDriver = new AutomationDriver();\r\n\r\n\t\t@Test\r\n\t\tpublic void demoTest() {\r\n\t\t   automationDriver.getWebDriver()..navigate().to(\"https://www.amazon.com\")\r\n\t\t\tHomePage homePage = new HomePage();\r\n\t\t\thomePage.toCarSearchPage();\r\n\t\t}\r\n\t}\r\n\r\n**You only need annotate the AutomationDriver with @Rule, automation framework would help you handle all the dirt work**\r\n\r\nA new way to handle navigation.\r\n-------------\r\nIf you have tens of Pages, It would be a nightmare to navigate between them. A very good practice is never new Page() in your test cases. I always define a Pages.java to handle all navigation.\r\nThis framework provide PageHelper to help you create new Pages and navigate between them. Only thing you need to know is which Page class you are navigate to.\r\n\r\n**New Code Sample**\r\n\r\n    public class Pages {\r\n        public static HomePage homePage() {\r\n            return PageHelper.toPage(HomePage.class);\r\n        }\r\n\r\n        public static CheckoutPage checkoutPage() {\r\n            return PageHelper.toPage(CheckoutPage.class);\r\n        }\r\n\r\n        public static CarSearchPage carSearchPage() {\r\n            return PageHelper.toPage(CarSearchPage.class);\r\n        }\r\n\r\n        public static CarSearchResultPage carSearchResultPage() {\r\n            return PageHelper.toPage(CarSearchResultPage.class);\r\n        }\r\n\r\n    }\r\n\r\n    public class NavigationTest {\r\n            @Test\r\n            public void navigationTest() {\r\n                Pages.homePage().toCarSearchPage();\r\n                Pages.carSearchPage().searchCar(\"Seattle\", \"SFO\");\r\n                Pages.searchResultPage().selectFirst();\r\n                Pages.checkoutPage().checkout();\r\n            }\r\n    }\r\n\r\n\r\nA new way to handle snapshot\r\n-------------\r\nHave you ever had this clickSubmit() function?\r\n\r\n    public class DemoPage {\r\n        public void clickSubmit() {\r\n               // Take snapshot\r\n                takeSnapshot(elementContext);\r\n\r\n                // click the element\r\n                webElement.click();\r\n\r\n                // Wait for Page Load Complete\r\n                NewPage newPage = new NewPage();\r\n                newPage.waitFor();\r\n            }\r\n    }\r\n\r\nToday it be more simple, clickAndToPage will help you.\r\n\r\n**New Code Sample**\r\n\r\n    public class DemoPage extends Page{\r\n        public void clickSubmit() {\r\n            clickAndToPage(webElement, NewPage.class);\r\n        }\r\n    }\r\n\r\nA new way to not full you test case with Fluent wait and avoid sleep\r\n-------------\r\nWe ever avoid Thread.sleep prefer Wait or FluentWait in our test cases, now You don't need to write FluentWait function again and again, and you should have a library to support like below:\r\n\r\n    public waitForElement(WebElement webElement) {\r\n        try{\r\n            Wait<WebDriver> wait = new WebDriverWait(webDriver, 100);\r\n            wait.until(new ExpectedCondition<Boolean>() {\r\n                public Boolean apply(final WebDriver webDriver) {\r\n                    try {\r\n                        element.isDisplayed\r\n                    } catch (final NoSuchElementException e) {\r\n                        return false;\r\n                    }catch (final StaleElementReferenceException e)\r\n                    {\r\n                        return false;\r\n                    }\r\n                }\r\n            });\r\n        } catch (TimeoutException e){\r\n            TimeoutException te = new TimeoutException(message + \" timeout!\", e);\r\n            throw te;\r\n        }\r\n    }\r\n\r\nToday you can just use the existing function in your Page object. it supports you wait for WebElement and any Element created by framework or Element you extended from CustomElement. Check WaitFunctions.java to see all the wait functions the framework supports.\r\n\r\n**New Code Sample**\r\n\r\n    private void fillLocationField(WebElement webElement, String location) {\r\n        webElement.clear();\r\n        webElement.sendKeys(location);\r\n        waitForElementToBeDisplayed(suggestionComponent);\r\n        suggestionSelectComponent.select(1);\r\n        waitForElementToBeAbsent(suggestionComponent);\r\n    }\r\n\r\nA new way you don't need to carry WebDriver everywhere\r\n-------------\r\nIf you have a Selenium test project, if you search WebDriver, how many it includes in your test cases? Do we really need it? This framework is trying to hide WebDriver from you. Framework can deduce webDriver from **Global** space or from parent Page object and inject it into Element. If you really want the WebDriver, just call:\r\n   WebDriver webDriver = this.getElementContext().getWebDriver();\r\n\r\nA new way you don't need call PageFactory any more.\r\n-------------\r\nI don't know how you make PageFactory to initialize a page object. In old days, I always define a parent Page object and it look like this:\r\n\r\n    public class PageBase {\r\n        public PageBase(WebDriver webDriver) {\r\n            initElements();\r\n        }\r\n\r\n        public void initElements() {\r\n             PageFactory.initElements(driver, ...);\r\n        }\r\n    }\r\n\r\n    public class HomePage extends PageBase {\r\n        public HomePage(WebDriver webDriver) {\r\n            super(webDriver);\r\n        }\r\n    }\r\n\r\nNow this functionality is implement by framework. You simply define you page like this. no constructor(WebDriver webDriver) any more.\r\n\r\n**New Code Sample**\r\n\r\n    public class HomePage extends Page {\r\n    }\r\n\r\nA new way to describe tables.\r\n-------------\r\nIn today's project, tables are created dynamically, and often it creates id like 'aria-option-0', 'aria-option-1', 'aria-option-2'.\r\nsee example https://github.com/licanhua/selenium-automation/tree/master/selenium-automation-example/src/main/java/framework/datatables\r\n\r\nA new way you don't need to care about configuration. (TDB)\r\n-------------\r\nA new way you don't need to handle URL. (TBD)\r\n-------------\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}