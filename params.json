{
  "name": "Selenium-automation",
  "tagline": "Selenium automation framework is not only a test automation framework, but also the best practice of using Selenium. It integrates a lot of 'new way' to the framework and provide you a new natural way to design and describe your pages. No more FlowWait for WebElement, new more new Page(), new more new Select(), no more WebElement.isDisplayed() in your test case. It provides more than that, please see the details.  ",
  "body": "Welcome to Selenium Automation Framework!\r\n===================\r\n**Selenium Automation Framework** Selenium Automation Framework(also call SAF) is not only a test automation framework, but also the best practice of using Selenium for automation testing. It provides nature way describe your web pages, and provides a lot of handy features to release you from the framework development. You can apply a lot of best practices of Selenium testing in one minute.\r\n\r\nThis framework provides:\r\n\r\n 1.  A nature way to describe a page and its content.\r\n 2. Automatically validate the presence of elements when creating a page.\r\n 3. Same testcase can be run against different browser like IE, Chrome, Firefox and even Selenium Grid without modification\r\n 4. Support Ajax element wait internally\r\n 5. @RelativeElement helps you locate relative elements without code\r\n 6. Easy way to describe tables.\r\n 7. New test data and configuration management\t\r\n 8. Select, CheckBox are WebElements.\r\n 9. Make use of @Rule annotation.\r\n 10. Best practice of page navigation.\r\n 11. Simple clickSubmit\r\n 12. Snapshot\r\n 13. Don't call findElement(s) directly any more\r\n 14. Avoid fluent wait and sleep to wait for WebElement \r\n 15. No PageFactory any more.\r\n 16. New test data from HOCON, JSON and propertie files\r\n\r\nA nature way to describe a page and its content.\r\n-------------\r\nDo you follow PageObjects pattern to design your test case? if yes, you already have a good start. PageFactory helps you inject all WebElement objects for you. That's very cool, but it's hard to describe a complex homepage. If we describe a homepage in nature language, it should like this:\r\n\r\n    A HomePage includes a header, a navigation page, a lot of components and footer.\r\n    - header provides account management, language ...\r\n    - navigation page includes flight, hotel, car ...\r\n   \r\nThis framework provides a nature way to organize and describe your Pages. This framework hide you from PageObjects and PageFactory. You can describe a object with a WebElement, but you can also group a lot of WebElement into a Container. A Page can includes any number of Containers, and a container can includes other contains of any WebElements. This framework helps you create the cascading of Page Objects in a Page no matter its inside is WebElement or a Container or Page. So the framework enables you to describe the homepage like this:\r\n\r\n    HomePage \r\n\t\t    - Header\r\n\t\t\t    - account management\r\n\t\t\t    - language\r\n\t\t    - Navigation\r\n\t\t\t    - car\r\n\t\t\t    - flight\r\nHere we express the relations in code:\r\n\r\n    class Header extends Container{\r\n\t    @Findby(id=\"account\")\r\n\t    WebElement accountManagement;\r\n\t}\r\n\r\n\tclass Navigation extends Container{\r\n\t\t@FindBy(id=\"flight\")\r\n\t\tWebElement flight;\r\n\t}\r\n\t\r\n\tclass HomePage extends Page{\r\n\t\t@FindBy(id=\"head\")\r\n\t\tHeader head;\r\n\t\t\r\n\t\t@FindBy(id=\"nav\")\r\n\t\tNavigation nav;\r\n\t}\r\n\t\r\n\tclass HomePageTest {\r\n\t\t@Test\r\n\t\tpublic void testHomePage() {\r\n\t\t\tHomePage homepage = new HomePage();\r\n\t\t}\r\n\t}\r\n\r\nAfter you defined **Header** and **Navigation**, you could treat them as **WebElement**. When you need the homepage, just **new HomePage()**. Framework would inject nav, header for you and everything is ready to use. No need to think about PageObject and PageFactory any more.\r\n\r\nAutomatically validate the presence of elements when creating a page.\r\n-------------\r\nBy default, when you create a Page, framework automatically help you validate the presence of its content. Like below example, when you `HomePage page = new HomePage()`, framework helps you wait until **nav** is existing or timeout. When you use the page object, nav and all other elements belongs to nav in in HomePage is ready for you to use except footer. framework validate all elements until you annotate a element with `@OptionalElement` or you annotate a class with `@AutoValidation(false)`. Exception would be thrown if validation fails.\r\n\r\n    public class HomePage extends Page {\r\n        @FindBy(id=\"wizard-theme-wrapper\")\r\n        Navigation nav;\r\n\r\n        @OptionalElement\r\n\t\t@FindBy(id=\"footer\")\r\n\t\tWebElement footer;\r\n        public void doSearch() {\r\n            nav.toCarSearchPage();\r\n        }\r\n    }\r\n\r\n    \r\n\r\nSame testcase can be run against different browser like IE, Chrome, Firefox and even Selenium Grid without modification\r\n-------------\r\nDon’t assume that driver will be an instance of FireFoxDriver or InternetExplorerDriver only. maybe It’s quite easy for you to create a small framework around selenium to support any browser. Now it's ready for you to use.\r\nJust change the configuration in **config/automation.properties** to the browser you need. we support Firefox, Chrome, IE to run locally and any browser with a remoteWebDriverAddress.\r\n\r\n    browserName=chrome\r\n    remoteWebDriverAddress=\r\n\r\nSystem properties take priority over configuration file. If you use mvn to do the test, you can change the behaviour dynamically by **-DbrowserName=firefox -DRemoteWebDriver =http://localhost:4444/wd/hub**.\r\n\r\nIf you want to talk to Remote WebDriver and want different DesiredCapabilities, just defined a config file in `config/browser/${browserName}.properties`. Framework would load this file automatically and negotiate with remote webdriver. Here is an example for firefox.\r\n\r\n    config/browser/firefox.properties\r\n        browserName=firefox\r\n        version=\r\n        platform=WINDOWS\r\n        javascriptEnabled=true\r\n        cssSelectorsEnabled=true\r\n\r\nSupport Ajax element wait internally\r\n-------------\r\nHow many times we use FluentWait to wait for a ajax element is ready for you in our test cases. Do you ever use `org.openqa.selenium.support.pagefactory.AjaxElementLocatorFactory`. Now framework makes it very simple and you need to do nothing. By default, all WebElement are initialized with `AjaxElementLocatorFactory`. If you are using ajaxElement like ajaxElement.click() and the element doesn't exist, it would wait the presence of this element until it timeouts.\r\n\r\n    public class HomePage {\r\n        @FindBy(id=\"ajax\")\r\n        @OptionalElement\r\n        WebElement ajaxElement;\r\n\r\n        public void doSomething() {\r\n            ajaxElement.click();\r\n        }\r\n    }\r\n\r\nIf you want to use implicit wait and fail immediately if no element is present, you just add `@AjaxEnabled(false)` to your class.\r\n\r\n    @AjaxEnabled(false)\r\n    public class HomePage {\r\n    }\r\n\r\nSelect, CheckBox are WebElements.\r\n-------------\r\nYou don't need do special handle for Select and CheckBox anymore. SelectBox and CheckBox is ready for you to use just like a normal WebElement.\r\n\r\n    public class DemoPage{\r\n        @FindBy(id=\"selectdemo\")\r\n        SelectBox selectElement;\r\n\r\n        @FindBy(id=\"checkboxDemo\")\r\n        CheckBox checkBoxElement;\r\n\r\n        public void selectByValue(String value) {\r\n            selectElement.selectByValue(value);\r\n        }\r\n\r\n        public void check() {\r\n            checkBoxElement.check();\r\n        }\r\n    }\r\n\r\nMake use of @Rule annotation.\r\n-------------\r\nIf you never use @Rule, I suggest you google it. It's worth your time to learn it and use it in your test framework. Now write automation is very easy, just add \r\n\r\n    @Rule\r\n    public AutomationDriver driver = new AutomationDriver();\r\n\r\nin your test cases, Selenium automation framework is automatically launched for you. \r\n\r\n\tclass DemoTest {\r\n\t\t@Rule\r\n\t\tpublic AutomationDriver driver = new AutomationDriver();\r\n\r\n\t\t@Test\r\n\t\tpublic void demoTest() {\r\n\t\t\tHomePage homePage = new HomePage();\r\n\t\t\thomePage.toCarSearchPage();\r\n\t\t}\r\n\t}\r\n\r\n**You only need annotate the AutomationDriver with @Rule, automation framework would help you handle all the dirt work**\r\n\r\nBest practice of page navigation.\r\n-------------\r\nIf you have tens of Pages, It would be a nightmare to navigate between them. A very good practice is never new Page() in your test cases. And always define a Pages.java to handle all navigation.\r\nThis framework provide PageHelper to help you create new Pages and navigate between them. Only thing you need to know is which Page class you are navigate to. The new created page is ready for you to use, and it includes all the features framework supports like auto validation, ajax element wait, ...\r\n\r\n    public class Pages {\r\n        public static HomePage homePage() {\r\n            return PageHelper.toPage(HomePage.class);\r\n        }\r\n\r\n        public static CheckoutPage checkoutPage() {\r\n            return PageHelper.toPage(CheckoutPage.class);\r\n        }\r\n\r\n        public static CarSearchPage carSearchPage() {\r\n            return PageHelper.toPage(CarSearchPage.class);\r\n        }\r\n\r\n        public static CarSearchResultPage carSearchResultPage() {\r\n            return PageHelper.toPage(CarSearchResultPage.class);\r\n        }\r\n\r\n    }\r\n\r\n    public class NavigationTest {\r\n            @Test\r\n            public void navigationTest() {\r\n                Pages.homePage().toCarSearchPage();\r\n                Pages.carSearchPage().searchCar(\"Seattle\", \"SFO\");\r\n                Pages.searchResultPage().selectFirst();\r\n                Pages.checkoutPage().checkout();\r\n            }\r\n    }\r\n\r\nDo you see the above test cases is very simple? framework does the validation and you handle the navigation.\r\n\r\nSimple clickSubmit\r\n-------------\r\nHave you ever written clickSubmit() function like this before?\r\n\r\n        public void clickSubmit() {\r\n               // Take snapshot\r\n               // click the element\r\n               // create new page\r\n               // wait for new page is ready\r\n               // validate the new page\r\n            }\r\n\r\n\r\nToday it be more simple, clickAndToPage will help you do everything mentioned above .\r\n\r\n     clickAndToPage(webElement, NewPage.class);\r\n\r\nSnapshot\r\n------------\r\nJust define `autoSnapshot=true`in any configuration file. and use clickAndToPage to click WebElement, snapshot is already taken for you.\r\n\r\nThere are two kinds of snapshot:\r\n1, the page source of webpage.  saved as 1-source.html\r\n2, the screen snapshot.  saved as 1-screenshot.png\r\nThey are created in testOutput like\r\ntestOutput\\20161030121459\\com.github.licanhua.example.datatables.test.DatatablesTest.datatablesTest\r\nTest time and test case is as part of the directory.\r\n\r\nDon't call findElement(s) directly any more\r\n-------------\r\nWhy do we need call findElement(s) by ourselves? Maybe because of the following two reason: \r\n\r\n One is for things like Select and RadioButton. Selenium don't support it you have to:\r\n\r\n    Select foo = new Select(sDriver.findElement(By.id(\"foo\")));\r\n    foo.selectByValue(\"myValue\");\r\n\r\nPlease use SelectBox\r\n\r\n    public class HomePage {\r\n        @FindBy(id=\"ajax\")\r\n        SelectBox select;\r\n\r\n        public void doSomething() {\r\n           select.selectByIndex(10);\r\n        }\r\n    }\r\n\r\n\r\nAnother one is find element relative to other element. Please use Container\r\n\r\n\r\nAvoid fluent wait and sleep to wait for WebElement \r\n-------------\r\nOne of the good practice is use FluentWait other than Thread.sleep. I want to say avoid fluent too. Ajax element is supported by framework and ajax element is suppose to be ready for use when you create pages.\r\n\r\nIf you still think it's not enough,  try to use wait functions from [WaitFunctions.java](https://github.com/licanhua/selenium-automation/blob/master/selenium-automation-framework/src/main/java/com/github/licanhua/test/framework/base/WaitFunctions.java).\r\nMark the element as `@OptionalElement`to skip the auto validation.\r\n\r\n\tpublic class CarSearchPage extends Page {\r\n\t    @OptionalElement\r\n\t    @FindBy(className=\"display-group-results\")\r\n\t    SuggestionSelectComponent suggestionSelectComponent;\r\n    \r\n\t    private void fillLocationField(WebElement webElement, String location) {\r\n\t        webElement.clear();\r\n\t        webElement.sendKeys(location);\r\n\t        waitForElementToBeDisplayed(suggestionComponent);\r\n\t        suggestionSelectComponent.select(1);\r\n\t        waitForElementToBeAbsent(suggestionComponent);\r\n\t    }\r\n\t}\r\n\t\r\nUse startPage configuration other than WebDriver navigate\r\n-------------\r\nBecause selenium need webDrive to navigate and locate element. If you have a Selenium test project, search WebDriver, how many times it occurs? Do we really need it? \r\nThis framework is hiding WebDriver from you. **startPage** is provided to help you get to the first page. define startPage in any configuration file like below.\r\n \r\n    startPage=https://datatables.net\r\n\r\n During the start up, framework would automatically navigate you to startpage and waitForPageLoadComplete. If you really want the WebDriver, just call:\r\n\r\n\tWebDriver webDriver = this.getElementContext().getWebDriver();\r\n\r\nNo PageFactory any more.\r\n-------------\r\nI don't know how you make PageFactory to initialize a page object. In old days, I always define a parent Page object and it look like this:\r\n\r\n    public class PageBase {\r\n        public PageBase(WebDriver webDriver) {\r\n            initElements();\r\n        }\r\n\r\n        public void initElements() {\r\n             PageFactory.initElements(driver, ...);\r\n        }\r\n    }\r\n\r\n    public class HomePage extends PageBase {\r\n        public HomePage(WebDriver webDriver) {\r\n            super(webDriver);\r\n        }\r\n    }\r\n\r\nNow this functionality is implement by framework. You simply define you page like this. \r\n\r\n    public class HomePage extends Page {\r\n    }\r\n\r\n@RelativeElement helps you locate relative elements without code\r\n-------------\r\nBy default, all @FindBy is search in all the webpage. If we describe the context like Table and Row, we need relative search. just put **@RelativeElement** in your relative element. framework would help you change the SearchContext to it's parent(Here position and office in ExampleRow has change SearchContext to By.className=sorting_1) \r\n\r\n\tpublic class ExampleRow extends Container {\r\n\t\t@RelativeElement\r\n\t\t@FindBy(xpath=\"./../td[2]\")\r\n\t\tWebElement postition;\r\n\r\n\t\t@RelativeElement\r\n\t\t@FindBy(xpath = \"./../td[4]\")\r\n\t\tWebElement office;\r\n\t}\r\n\r\n\tpublic class ExampleTable extends Container {\r\n\t\t@FindBy(className=\"sorting_1\")\r\n\t\tList<ExampleRow> rows;\r\n\t}\t\r\n\r\n\r\nEasy way to describe tables.\r\n-------------\r\nIn today's project, tables are created dynamically, and often it creates id like 'aria-option-0', 'aria-option-1', 'aria-option-2'. we can make use of @RelativeElement above to achieve this\r\nsee [Examples](https://github.com/licanhua/selenium-automation/tree/master/selenium-automation-example/src/main/java/com/github/licanhua/example/datatables/test)\r\n\r\n\r\nNew test data and configuration management\r\n--------------\r\nIn order to support flex test data source, framework supports **HOCON**, **JSON** and **properties** format. and even support to extend data source from database to any network resource(Just need implement a ConfigService).\r\n\r\nBefore we go forward, let see the following definition:\r\n\r\n 1. **testMethodName**: the current running method name like testValidInput.\r\n 2. **targetEnvironment**: it's like prod, integration, dev, test   \r\n 3. **Search priority**: for the same key, different value will be got from Configuration. If we search for a key, the following search order will be execute until a value if find.\r\n\t  ${testMethodName}.${targetEnvironment}.${key}\r\n\t  ${testMethodName}.{key}\r\n\t  ${targetEnvironment}.${key}\r\n\t ${key}\r\n 4. **Configuration** Files: if your testMethodName package is a.b.c.d, then framework will search all the configurations *a.(json, conf, properties)*, *a.b.(json, conf, properties)*, *a.b.c.(json, conf, properties)*, *a.b.c.d.(json, conf, properties)*. If we defined the same key in multiple files, the later will overwrite the before ones.    \r\n    \r\nFor example, we have a test com.licanhua.Test.demo(). testMethodName is demo. and three configuration will be loaded. I assume all are json files.\r\n\r\n\tcom.json\r\n\tcom.licanhua.json\r\n\tcom.licanhua.Test.json\r\n\r\nIf com.licanhua.Test.json like:\r\n\r\n\t{\r\n\t\tdemo: {\r\n\t\t\tprod: {\r\n\t\t\t\t\"userName\": \"demoInProd\"\r\n\t\t\t}, test: {\r\n\t\t\t\t\"userName\": \"testInProd\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tprod: {\r\n\t\t\t\"userName\": \"demo\"\r\n\t\t},\r\n\t\t\"userName\": \"test\",\r\n\t\t\"password\": \"got it\"\r\n\t}\r\n\r\nIf we call getString(\"password\") from demo method, and targetEnv is prod, we will search password in the following order and finally get '**got it'**\r\n\r\n\tdemo.prod.password\r\n\tdemo.password\r\n\tprod.password\r\n\tpassword\r\n\r\nif we search userName, demo.prod.userName is matched and be returned with **demoInProd**\r\n\t\r\nNew test data from HOCON, JSON and propertie files\r\n--------------\r\nFramework use [typesafe](https://github.com/typesafehub/config) as configuration reader, so it supports HOCON, JSON and properties. You should define the configuration with ext name with one of them from: **.conf**, **.json** or **.properties**\r\n\r\nSeparate the test data from test code by configuration service.\r\n--------------\r\nAny time you can get the configuration by getConfiguration()\r\n\r\n\tpublic HomePage extens Page {\r\n\t\tpublic void loginAsGuest() {\r\n\t\t\tConfiguration conf = getConfiguration();\r\n\t\t\tString name = conf.getString(\"guestName\");\r\n\t\t\tString password =conf.getString(\"guestPassword\");\r\n\t\t\tloginAs(name, password);\r\n\t\t}\r\n\t}\r\n\t\r\n\t",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}